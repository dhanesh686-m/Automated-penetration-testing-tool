import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import subprocess
import os
from datetime import datetime
import threading
import platform

current_datetime = datetime.now()

def generate_report_content(nmap_output, nikto_output, target):
    """
    Generates a basic report based on simulated scan outputs.
    """
    report_content = (
        f"*** Penetration Test Report ***\n"
        f"Date & Time: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"Target: {target if target else 'N/A'}\n\n"
        f"--- Nmap Scan Results ---\n"
        f"{nmap_output}\n\n"
        f"--- Nikto Scan Results ---\n"
        f"{nikto_output}\n\n"
        f"--- Summary ---\n"
        f"This report summarizes the findings from the automated penetration tests performed.\n"
        f"Please review the detailed outputs from Nmap and Nikto for specific vulnerabilities.\n\n"
        f"--- Recommendations (General) ---\n"
        f"1. Ensure all unnecessary ports are closed.\n"
        f"2. Implement robust security headers (e.g., X-Frame-Options, Content-Security-Policy).\n"
        f"3. Regularly update server software and frameworks.\n"
        f"4. Restrict directory indexing and sensitive file access.\n\n"
        f"--- End of Report ---\n"
    )
    return report_content


class PenTestTool:
    def __init__(self, master):
        self.master = master
        master.title("Penetration Testing Automation Tool")
        master.geometry("900x800") # Increased size for better layout
        master.configure(bg="#212121") # Deeper dark background

        # Variables to store scan outputs
        self.nmap_output = ""
        self.nikto_output = ""
        self.metasploit_output = "" # Placeholder for future Metasploit integration

        # --- Styling ---
        self.style = ttk.Style()
        self.style.theme_use('alt') # 'clam' provides a good base for customization

        # Define a consistent font family
        self.font_family = 'Segoe UI' if platform.system() == 'Windows' else 'Helvetica Neue'

        # General background and foreground colors
        self.primary_bg = "#2b2b2b" # Dark grey
        self.secondary_bg = "#3a3a3a" # Slightly lighter dark grey
        self.text_color = "#e0e0e0" # Light grey for text
        self.accent_color = "#64ffda" # Teal accent for highlights
        self.button_color = "#00796b" # Darker teal for buttons
        self.button_active_color = "#004d40" # Even darker teal for active buttons
        self.error_color = "#ef5350" # Red for errors/titles

        self.style.configure('TFrame', background=self.primary_bg, borderwidth=0, relief="flat")
        self.style.configure('TLabel', background=self.primary_bg, foreground=self.text_color, font=(self.font_family, 10))
        self.style.configure('TButton',
                             background=self.button_color,
                             foreground='white',
                             font=(self.font_family, 10, 'bold'),
                             borderwidth=0,
                             focusthickness=3,
                             focuscolor=self.accent_color
                            )
        self.style.map('TButton',
                       background=[('active', self.button_active_color)],
                       foreground=[('active', 'white')]
                      )
        self.style.configure('TEntry',
                             fieldbackground="#424242", # Slightly lighter than primary_bg for input fields
                             foreground=self.text_color,
                             insertbackground=self.accent_color, # Cursor color
                             borderwidth=1,
                             relief="flat"
                            )
        self.style.configure('TScrolledtext',
                             background="#1a1a1a", # Even darker for output console
                             foreground=self.accent_color, # Teal output text
                             font=('Consolas', 9),
                             insertbackground=self.text_color # Cursor in output
                            )
        self.style.configure('TCheckbutton',
                             background=self.primary_bg,
                             foreground=self.text_color,
                             font=(self.font_family, 10),
                             relief="flat",
                             padding=(5, 5)
                            )
        self.style.map('TCheckbutton',
                       background=[('active', self.primary_bg)], # Keep background same on hover
                       foreground=[('active', self.accent_color)] # Change foreground to accent color on hover
                      )
        self.style.configure(
            'Checkbutton.indicator', 
            background="White",      # Background of the un-checked box
            foreground="Black",     # Color of the tick when checked
            relief='flat',            # No 3D relief for the indicator box itself
            borderwidth=0)
        # Style for the title label specifically
        self.style.configure('Title.TLabel',
                             background=self.primary_bg,
                             foreground=self.error_color, # Use error color for a striking title
                             font=(self.font_family, 20, 'bold')
                            )
        # Style for status bar
        self.style.configure('Status.TLabel',
                             background=self.secondary_bg,
                             foreground=self.text_color,
                             font=(self.font_family, 9, 'italic')
                            )
        
        # --- Layout ---
        # Main Frame with more padding
        self.main_frame = ttk.Frame(master, padding="20")
        self.main_frame.pack(expand=True, fill="both")

        # Title
        self.title_label = ttk.Label(self.main_frame, text="Automated PenTest Tool", style='Title.TLabel')
        self.title_label.pack(pady=(0, 20)) # More padding at bottom

        # Target Input Frame
        self.target_frame = ttk.Frame(self.main_frame, style='TFrame')
        self.target_frame.pack(pady=10, fill="x", padx=10) # Added padx
        self.target_label = ttk.Label(self.target_frame, text="Target IP/Domain:")
        self.target_label.pack(side="left", padx=(0, 10))
        self.target_entry = ttk.Entry(self.target_frame, width=40, font=(self.font_family, 10)) # Increased width, applied font
        self.target_entry.pack(side="left", expand=True, fill="x")
        self.target_entry.insert(0, "") 
        
        # Nikto Specific Options Frame
        self.nikto_options_frame = ttk.Frame(self.main_frame, style='TFrame')
        self.nikto_options_frame.pack(pady=5, fill="x", padx=10)

        self.port_label = ttk.Label(self.nikto_options_frame, text="Port:")
        self.port_label.pack(side="left", padx=(0, 10))
        self.port_entry = ttk.Entry(self.nikto_options_frame, width=10, font=(self.font_family, 10))
        self.port_entry.pack(side="left", padx=(0, 20))
        self.port_entry.insert(0, "")

        self.ssl_var = tk.BooleanVar(value=False)
        self.ssl_check = ttk.Checkbutton(self.nikto_options_frame, text="Use SSL (HTTPS)", variable=self.ssl_var)
        self.ssl_check.pack(side="left")

        # Action Buttons Frame - using grid for better alignment
        self.button_frame = ttk.Frame(self.main_frame, style='TFrame')
        self.button_frame.pack(pady=20) # More vertical spacing

        self.nmap_button = ttk.Button(self.button_frame, text="1. Run Nmap (Recon)", command=self.run_nmap)
        self.nmap_button.grid(row=0, column=0, padx=8, pady=5)

        self.nikto_button = ttk.Button(self.button_frame, text="2. Run Nikto (Scan)", command=self.run_nikto)
        self.nikto_button.grid(row=0, column=1, padx=8, pady=5)
        
        self.metasploit_button = ttk.Button(self.button_frame, text="3. Run Metasploit (Exploit - Simulated)", command=self.run_metasploit_simulated)
        self.metasploit_button.grid(row=0, column=2, padx=8, pady=5)

        self.report_button = ttk.Button(self.button_frame, text="4. Generate Report", command=self.generate_report)
        self.report_button.grid(row=0, column=3, padx=8, pady=5)

        # Output Area
        self.output_label = ttk.Label(self.main_frame, text="Scan/Report Output:", font=(self.font_family, 11, 'bold'))
        self.output_label.pack(pady=(10, 5), anchor='w', padx=10) # Align left
        self.output_text = scrolledtext.ScrolledText(self.main_frame, width=90, height=25, wrap=tk.WORD,
                                                     relief="flat", borderwidth=0) # Removed border from text widget
        self.output_text.pack(expand=True, fill="both", padx=10, pady=(0, 10))
        self.output_text.configure(state='disabled') # Make it read-only

        # Status Bar
        self.status_bar = ttk.Label(self.main_frame, text="Ready", relief=tk.FLAT, anchor=tk.W, style='Status.TLabel')
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X, pady=(10,0))

    # --- Button Command Handlers ---

    def _update_output(self, text):
        """Helper to update the scrolled text widget completely."""
        self.output_text.configure(state='normal')
        self.output_text.delete(1.0, tk.END)
        self.output_text.insert(tk.END, text)
        self.output_text.configure(state='disabled')
        self.output_text.see(tk.END) # Scroll to bottom

    def _update_output_live(self, text):
        """Helper to append text to the scrolled text widget for live updates."""
        self.output_text.configure(state='normal')
        self.output_text.insert(tk.END, text)
        self.output_text.configure(state='disabled')
        self.output_text.see(tk.END) # Scroll to bottom

    def _update_status(self, message):
        """Helper to update the status bar."""
        self.status_bar.config(text=message)

    def run_nmap(self):
        target = self.target_entry.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target IP or domain for Nmap scan.")
            return

        self._update_status(f"Running Nmap scan on {target}...")
        
        # It's generally not recommended to scan random public IPs without permission.
        # For demonstration, 'scanme.nmap.org' is a safe and legal target.
        if target not in ["127.0.0.1", "localhost", "scanme.nmap.org"]:
            response = messagebox.askyesno("Warning", f"Scanning {target} without explicit permission may be illegal or unethical. Do you want to proceed? (Recommended to use 'scanme.nmap.org' for testing)")
            if not response:
                self._update_status("Nmap scan cancelled by user.")
                return

        def nmap_thread_task():
            try:
                if platform.system() == "Windows":
                    nmap_executable = "nmap.exe" 
                else: 
                    nmap_executable = "nmap"

                command = [nmap_executable, "-sV", target] 
                
                process = subprocess.run(command, capture_output=True, text=True, check=True, timeout=600, shell=False) 
                self.nmap_output = process.stdout
            except subprocess.CalledProcessError as e:
                self.nmap_output = f"Nmap error: \nSTDOUT: {e.stdout}\nSTDERR: {e.stderr}"
                self.master.after(0, lambda: messagebox.showerror("Nmap Error", f"Nmap scan failed for {target}. Check output for details.\n{self.nmap_output}"))
            except FileNotFoundError:
                self.nmap_output = "Error: Nmap not found. Please ensure Nmap is installed and in your PATH."
                self.master.after(0, lambda: messagebox.showerror("Tool Not Found", "Nmap executable not found. Is it installed and in your PATH?"))
            except subprocess.TimeoutExpired:
                self.nmap_output = f"Nmap scan timed out after 600 seconds for {target}."
                self.master.after(0, lambda: messagebox.showwarning("Scan Timeout", f"Nmap scan timed out for {target}. It might be taking too long or the target is unresponsive."))
            except Exception as e:
                self.nmap_output = f"An unexpected error occurred during Nmap scan: {e}"
                self.master.after(0, lambda: messagebox.showerror("Unexpected Error", f"An unexpected error occurred during Nmap scan: {e}"))

            self.master.after(0, self._update_output, self.nmap_output)
            self.master.after(0, self._update_status, f"Nmap scan completed for {target}.")
            self.master.after(0, lambda: messagebox.showinfo("Nmap Scan Complete", "Nmap reconnaissance scan has completed and its output is displayed."))

        thread = threading.Thread(target=nmap_thread_task)
        thread.daemon = True # Allow the thread to exit with the main program
        thread.start()


    def run_nikto(self):
        target = self.target_entry.get().strip()
        port = self.port_entry.get().strip()
        use_ssl = self.ssl_var.get()

        if not target:
            messagebox.showerror("Error", "Please enter a target IP or domain for Nikto scan.")
            return
        if not port.isdigit() or not (1 <= int(port) <= 65535):
            messagebox.showerror("Invalid Port", "Please enter a valid port number (1-65535).")
            return
        
        # Ethical considerations for Nikto as well
        if target not in ["127.0.0.1", "localhost", "scanme.nmap.org"]: # Nikto against Nmap.org isn't typical but added for example
            response = messagebox.askyesno("Warning", f"Scanning {target} without explicit permission may be illegal or unethical. Do you want to proceed? (Recommended to use 'scanme.nmap.org' or your own controlled environment for testing)")
            if not response:
                self._update_status("Nikto scan cancelled by user.")
                return

        self._update_status(f"Running Nikto scan on {target}:{port} (SSL: {use_ssl})...")
        self.output_text.configure(state='normal')
        self.output_text.delete(1.0, tk.END)
        self.output_text.configure(state='disabled')

        def nikto_thread_task():
            try:
                command = []
                if platform.system() == "Windows":
                    # IMPORTANT: REPLACE THESE PATHS WITH YOUR ACTUAL INSTALLATION PATHS ON WINDOWS!
                    # Make sure these paths are correct for your system for Nikto to work.
                    perl_executable = r"C:\Strawberry\perl\bin\perl.exe"  # Example for Strawberry Perl
                    nikto_script_path = r"C:\nikto\program\nikto.pl" # Example path to extracted nikto.pl

                    if not os.path.isfile(perl_executable):
                        self.master.after(0, lambda: messagebox.showerror("File Not Found", f"Perl interpreter not found at {perl_executable}. Please install Perl and update the path in the script."))
                        self.master.after(0, self._update_status, f"Nikto scan failed for {target}.")
                        return
                    if not os.path.isfile(nikto_script_path):
                        self.master.after(0, lambda: messagebox.showerror("File Not Found", f"Nikto script not found at {nikto_script_path}. Please extract Nikto and update the path in the script."))
                        self.master.after(0, self._update_status, f"Nikto scan failed for {target}.")
                        return
                    
                    command = [perl_executable, nikto_script_path, "-h", target, "-p", port, "-T", "60", "-Display", "V"]
                    if use_ssl:
                        command.append("-ssl")
                else: # Linux, macOS, etc.
                    # Standard path for Nikto on Kali and other Debian-based systems
                    nikto_script_path = r"/usr/bin/nikto" 
                    if not os.path.isfile(nikto_script_path):
                        self.master.after(0, lambda: messagebox.showerror("File Not Found", f"Nikto script not found at {nikto_script_path}. Please ensure Nikto is installed (e.g., 'sudo apt install nikto')."))
                        self.master.after(0, self._update_status, f"Nikto scan failed for {target}.")
                        return
                    command = [nikto_script_path, "-h", target, "-p", port, "-T", "60", "-Display", "V"]
                    if use_ssl:
                        command.append("-ssl")

                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)

                temp_nikto_output = ""
                for line in process.stdout:
                    temp_nikto_output += line
                    self.master.after(0, self._update_output_live, line)

                process.wait()

                self.nikto_output = temp_nikto_output
                if process.returncode != 0:
                    self.master.after(0, lambda: messagebox.showwarning("Nikto Scan Warning", f"Nikto scan for {target} finished with non-zero exit code {process.returncode}. Check output for details."))
                
                self.master.after(0, self._update_status, f"Nikto scan completed for {target}.")
                self.master.after(0, lambda: messagebox.showinfo("Nikto Scan Complete", "Nikto vulnerability scan has completed and its output is displayed."))

            except Exception as e:
                self.master.after(0, lambda: messagebox.showerror("Unexpected Error", f"An unexpected error occurred during Nikto scan: {e}"))
                self.master.after(0, self._update_status, f"Nikto scan failed for {target}.")

        thread = threading.Thread(target=nikto_thread_task)
        thread.daemon = True
        thread.start()

    def run_metasploit_simulated(self):
        target = self.target_entry.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target IP or domain for Metasploit simulation.")
            return

        self._update_status(f"Running Metasploit simulation on {target}...")
        self.metasploit_output = (
            f"Simulating Metasploit exploitation attempt against {target}...\n\n"
            f"Note: Direct Metasploit integration requires advanced setup and "
            f"is simulated here for demonstration. Actual exploitation attempts "
            f"must be done ethically and with explicit permission.\n\n"
            f"[msf > use exploit/multi/http/tomcat_mgr_deploy]\n"
            f"[msf exploit(tomcat_mgr_deploy) > set RHOSTS {target}]\n"
            f"[msf exploit(tomcat_mgr_deploy) > set USERNAME tomcat]\n"
            f"[msf exploit(tomcat_mgr_deploy) > set PASSWORD s3cret]\n"
            f"[msf exploit(tomcat_mgr_deploy) > exploit]\n\n"
            f"[*] Exploitation finished.\n"
            f"[*] Meterpreter session 1 opened (127.0.0.1:4444 -> {target}:80)\n"
            f"--- End of Metasploit Simulation ---"
        )
        self._update_output(self.metasploit_output)
        self._update_status(f"Metasploit simulation completed for {target}.")
        messagebox.showinfo("Metasploit Simulation", "Metasploit exploitation attempt has been simulated. Real Metasploit integration requires its RPC API or scripting and ethical considerations.")


    def generate_report(self):
        target = self.target_entry.get().strip()
        if not self.nmap_output and not self.nikto_output and not self.metasploit_output:
            messagebox.showwarning("Warning", "No scan or simulation data available. Please run Nmap, Nikto, and/or Metasploit simulations first.")
            return

        self._update_status("Generating penetration test report...")
        report = generate_report_content(self.nmap_output or "No Nmap scan data.",
                                         self.nikto_output or "No Nikto scan data.",
                                         target)
        self._update_output(report)
        self._update_status("Report generated.")
        messagebox.showinfo("Report Generated", "The penetration test report has been generated and is displayed in the output area.")

def main():
    root = tk.Tk()
    app = PenTestTool(root)
    root.mainloop()

if __name__ == "__main__":
    main()
